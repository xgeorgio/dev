% (demo script) Create realistic fMRI data series and perform decomposition
%---------------------------------------------------------------------------
%
%    PROJECT:        Sparse/fMRI
%    PACKAGE:        Code Demo/Template Routines
%    FILE:           'run2_createRealSeries.m'
%
%    PURPOSE:        create block pattern series and decompose
%    VERSION:        2.9
%
%    STAGE:          BETA
%    UPDATED:        20-Sept-2013/21:35
%
%    HISTORY:        version 2.9: added option for non-neg.mat.fact. KSVD (20-Sept-2013/21:33)
%                    version 2.8: adaptive per-component subplots (20-Sept-2013/20:00)
%                    version 2.7: added KSVD processing section (20-Sept-2013/18:15)
%                    version 2.6: complete run template for CCA (13-Jul-2013/20:35)
%                    version 2.5: added per-component correlation coeff (19-Jun-2013/19:40)
%                    version 2.4: added per-component p-value display (19-Jun-2013/18:55)
%                    version 2.3: complete run template for MP (18-Jun-2013/18:25)
%                    version 2.2: complete run template for GLM (18-Jun-2013/16:00)
%                    version 2.1: complete run template for ICA (18-Jun-2013/12:30)
%                    version 2.0: complete run template for PCA (18-Jun-2013/10:20)
%                    version 1.9: implemented core functionality (10-Jun-2013/20:35)
%
%    DESCRIPTION:    Use basic routines from the package to create a full 'real-like'
%                    simulated fMRI test dataseries, with pre-specified components
%                    and noise artifacts. The data are generated by a stand-alone
%                    function, i.e., this scripts is only for the test-runs.
%                    The 3-D data are then vectorized ('flattened') and devectorized
%                    ('deflattened'), enriched with noise and decomposed in various
%                    ways, including (partial) PCA, etc.
%
%    INPUT:          (see source code for details)
%
%    OUTPUT:         (see source code for details)
%
%    SEE ALSO:       run1_createblockseries.m
%
%    AUTHOR:         Harris Georgiou (MSc,PhD) - <a href="matlab:web('http://xgeorgio.info')">xgeorgio.info</a>
%    COMPANY:        Informatics & Telecommunications Department,
%                    Kapodistrian University of Athens (NKUA/UOA)
%    COPYRIGHT:      Harris Georgiou (CC-BY-SA) 20-Sept-2013
%
%---------------------------------------------------------------------------


%... initialize ...
clear all;
close all;

fmri_szX=100;           % defines size of each fMRI 'slice'
fmri_szY=100; 
fmri_szT=150;

flag_genshow=0;        % show sequence of images ('slices') after generation, set to figure#no (e.g. 10)
flag_imshow=0;          % show sequence of images ('slices') after reconstruction

flag_cmpshow=1;         % show components as images ('slices') after reconstruction
%cmpshow_szR=3;         % (inactive) per-component subplot rows, now adaptively calculated
%cmpshow_szC=4;         % (inactive) per-component subplot cols, now adaptively calculated

flag_errshow=1;         % plot reconstruction error of each 'slice' against T

flag_pause=0;           % pause between plots/results (in secs), 0 = no pause
disp_fps=5;             % frames-per-second (approx) when displaying fMRI series

flag_calcCorr=0;        % show correlation map after analysis/decomposition
flag_calcPval=0;        % show p-value map after analysis/decomposition
Pval_limit=0.001;       % p-value activation threshold (<= means 'active') (0 = full display)

flag_doPCA=0;           % perform PCA analysis/reconstruction
pca_Kp=8;               % number of PCA components to retain

flag_doICA=0;           % perform ICA (fastica) analysis/reconstruction
ica_Kp=8;               % number of ICA components to retain

flag_doGLM=0;           % perform GLM (mvregress) analysis/reconstruction
%glm_Kp=4;               % updated dynamically before actual fit

flag_doCCA=0;           % perform CCA analysis/reconstruction

flag_doMP=0;            % perform MP (wmpalg) analysis/reconstruction
mp_alg='OMP';           % MP algorithm to use: 'BMP', 'OMP', 'WMP'
%mp_Kp=2;                % Mp reconstruction components (use -1 for all)

flag_doKSVD=1;          % perform KSVD analysis/reconstruction
ksvd_Kp=20;             % number of total KSVD components (dictionary size)
ksvd_Lp=3;              % number of used KSVD components (sparsity level, Lp<=Kp)
ksvd_iterN=200;         % number of training iterations
ksvd_mode=1;            % (0): use fixed # atoms (Lp) / (1): discover # atoms (by ksvd_errStop)
ksvd_fixedDC=1;         % keep 1st atom fixed (DC) during training
ksvd_errStop=1e-3;      % only used when ksvd_mode=1 (total RMSE)
ksvd_useNNMF=0;         % use non-negative matrix factorization KSVD variant (ksvd_fixedDC=0 by default)

tic;

%... create basic patterns and series ...
fprintf('Generating fMRI series: [%dx%d] x %d\n\n',fmri_szX,fmri_szY,fmri_szT);

[D0,D1,W,SC]=vxCreateRealData(fmri_szX,fmri_szY,fmri_szT,flag_genshow);

T1=W(:,1);                      % default task-related (ideal) response

T1t=T1;                         % create thresholded version of ideal response
t1min=min(T1);
t1max=max(T1);
t1lim=(t1max+t1min)/2;
T1t(T1<=t1lim)=t1min;
T1t(T1>t1lim)=t1max;

Nelem=fmri_szX*fmri_szY*fmri_szT;      % total number of data elements (cells)

%... prepare series for processing (flatten) ...
fprintf('\tgenerating vectorized data series... ');
V0=vxVectorize(D0);             % all components (full mixture)
V1=vxVectorize(D1);             % task-related (ideal) response

if (flag_pause)
    fprintf('\n...<press any key to continue>... ');
    pause;
end;


%... basic PCA analysis/reconstruction block ...
if (flag_doPCA)
    fprintf('done\n\tperforming PCA (Kp=%d) decomposition of patterns series... ',pca_Kp);
    
    % V0 (NxL): rows N are samples, cols L are variables (dim)
    % COEFF (LxN): cols N are principal components (vectors) in descending signifficance
    % SCORE (NxN): rows N are projection of input rows onto COEFF components (vectors)
    % Note: disable normalization, for easier reconstruction
    % Static activation map for component j can be retrieved with: 
    %     vxDevectorize( COEFF(j,:), fmri_szX, fmri_szY )
    % Temporal activation series for component j is in:
    %     SCORE(:,j)
    
    [COEFF, SCORE, LATENT, TSQUARED, EXPLAINED, MU] = pca(V0,'NumComponents',pca_Kp,'Centered',false);
    
    COEFF=COEFF';                                       % transpose to set 'time' axis on row-wise format
    Vpca=SCORE(:,1:pca_Kp)*COEFF(1:pca_Kp,:);           % PCA-reconstruct using only Kp largest components (no rescaling)
    Dpca=vxDevectorize(Vpca,fmri_szX,fmri_szY);         % using: vxDevectorize32()

    ACFpca=zeros(pca_Kp,1);
    Dpca_cmp=zeros(fmri_szX,fmri_szY,fmri_szT,pca_Kp);  % create per-component reconstruction (for further analysis)
    for c=1:pca_Kp
        ACFpca(c)=corr(T1,SCORE(:,c));                  % per-component correlation coeff with primary activation series
        Dpca_cmp(:,:,:,c)=vxDevectorize(SCORE(:,c)*COEFF(c,:),fmri_szX,fmri_szY);
    end;       
 
    Vpca_error=zeros(fmri_szT,1);               % calculate per-slice reconstruction error
    for k=1:fmri_szT
        Vpca_error(k)=sum(abs(Vpca(k,:)/V0(k,:)-1))/(fmri_szX*fmri_szY);    % MRPE: Mean.Rel.Pred.Error
    end;
    
    Vpca_expl=sum(EXPLAINED(1:pca_Kp));          % calculate explained variance from calculated PCA components
    fprintf('done\n\t\tcomp.expl.var. = %.3f\n',Vpca_expl);
    
    if (flag_errshow)
        figure(1);
        plot(Vpca_error);
        msg=sprintf('PCA reconstruction error using %d compoments',pca_Kp);
        title(msg);
    end;
    
    if (flag_imshow)
        fprintf('done\n\tdisplaying PCA-reconstructed (Kp=%d/Vexpl=%.2f) pattern series... ',pca_Kp,Vpca_expl);
        for k=1:fmri_szT,
            figure(2);
            %imshow(mat2gray(Dpca(:,:,k)'));
            imagesc(Dpca(:,:,k)');
            colormap gray;
            title('fMRI sample series: PCA reconstruction');
            pause(1/disp_fps);
        end;
    end;

    if (flag_cmpshow)
        fprintf('done\n\tdisplaying PCA component-based reconstructions (Kp=%d)... ',pca_Kp);
        %close 3;        % make sure no previous components are displayed in subplots
        for k=1:fmri_szT,
            figure(3);
            cmpshow_szR=ceil(sqrt(pca_Kp+1));  % split the plot into appropriate sections
            cmpshow_szC=cmpshow_szR;
            for c=1:pca_Kp
                subplot(cmpshow_szR,cmpshow_szC,c);
                imagesc(Dpca_cmp(:,:,k,c)');
                colormap gray;
                msg=sprintf('PCA.%d / |r|=%.3f',c,ACFpca(c));
                title(msg);
            end;
            subplot(cmpshow_szR,cmpshow_szC,cmpshow_szR*cmpshow_szC);
            imagesc(Dpca(:,:,k)');
            colormap gray;
            msg=sprintf('PCA.all / T=%d',k);
            title(msg);
            pause(1/disp_fps);
        end;
    end;
    
    % calculate correlation/p-value maps
    if ((flag_calcCorr)||(flag_calcPval))
        fprintf('done\n\tcalculating Correlation/P-value maps... ');
        % calculate correlation (RC) and p-value (PV) maps, convert to 2-D 'images' for plot
        % Note: PV should be examined along with sign(RC) for full component-wise inference
        [RC,PV]=vxCalcActivMap(T1,Vpca,Pval_limit);
        RCM=vxDevectorize(RC,fmri_szX,fmri_szY);
        PVM=vxDevectorize(PV,fmri_szX,fmri_szY);
    
        if (flag_calcCorr)
            figure(4);
            mesh(RCM');
            title('Correlation matrix: full PCA / comp.T1');        
        end;
    
        if (flag_calcPval)
            figure(6);
            contour(PVM');
            title('P-value matrix: full PCA / comp.T1');        
        end;

        %close 5 7;        % make sure no previous components are displayed in subplots
        cmpshow_szR=ceil(sqrt(pca_Kp+1));  % split the plot into appropriate sections
        cmpshow_szC=cmpshow_szR;
        for c=1:pca_Kp
            [RC,PV]=vxCalcActivMap(T1,vxVectorize(Dpca_cmp(:,:,:,c)),Pval_limit);
            RCM=vxDevectorize(RC,fmri_szX,fmri_szY);
            PVM=vxDevectorize(PV,fmri_szX,fmri_szY);
            
            if (flag_calcCorr)
                figure(5);
                subplot(cmpshow_szR,cmpshow_szC,c);
                imagesc(RCM');
                msg=sprintf('PCA.%d / |r|=%.3f',c,ACFpca(c));
                title(msg);
            end;

            if (flag_calcPval)
                figure(7);
                subplot(cmpshow_szR,cmpshow_szC,c);
                imagesc(PVM');
                msg=sprintf('PCA.%d / |r|=%.3f',c,ACFpca(c));
                title(msg);
            end;
        end;           
    end;

    % calculate reconstruction inconsistency
    fprintf('done\n\tMean.Rel.Pred.Error: sum(|PCA/orig-1|)/n = %f\n',sum(sum(abs(Vpca/V0-1)))/Nelem);
    
    if (flag_pause)
        fprintf('\n\t...<press any key to continue>...\n');
        pause;
    end;
end;

%... basic ICA analysis/reconstruction block ...
if (flag_doICA)
    fprintf('\n\tperforming ICA (fastica) decomposition of patterns series... ');
    
    % V0 (NxL): rows N are samples, cols L are variables (dim)
    % A (NxK): ICA mixing matrix for K components
    % icasig (KxL): rows K are ICA components (vectors) of length L
    % Note: decompose into two main ICA components plus one more for noise
    % Static activation map for component j can be retrieved with: 
    %     vxDevectorize( icasig(j,:), fmri_szX, fmri_szY )
    % Temporal activation series for component j is in:
    %     A(:,j)
    
    [icasig, A, Demix] = fastica (V0,'numOfIC',ica_Kp,'g','tanh','stabilization','on');
    ica_Kp=size(icasig,1);          % get the final number of ICA components (returned)

    CP=zeros(1,size(icasig,1));             % perform ICA components sorting and selection:
    for c=1:size(icasig,1)
        CP(c)=sum(icasig(c,:).^2);          %   (1) calculate total energy of each component
    end;
    [CPS,IS]=sort(CP,'descend');            %   (2) sort component in descending power order
    A=A(:,IS);                              %   (3) rearrange components in matrices
    icasig=icasig(IS',:);
    
    Vica=A(:,1:ica_Kp)*icasig(1:ica_Kp,:);              % ICA-reconstruct using the (reduced) components
    Dica=vxDevectorize(Vica,fmri_szX,fmri_szY);         % using: vxDevectorize32()

    ACFica=zeros(ica_Kp,1);
    Dica_cmp=zeros(fmri_szX,fmri_szY,fmri_szT,ica_Kp);  % per-component reconstruction (for further analysis)
    for c=1:ica_Kp
        ACFica(c)=corr(T1,A(:,c));                      % per-component correlation coeff with primary activation series
        Dica_cmp(:,:,:,c)=vxDevectorize(A(:,c)*icasig(c,:),fmri_szX,fmri_szY);
    end;       
        
    Vica_error=zeros(fmri_szT,1);               % calculate per-slice reconstruction error
    for k=1:fmri_szT
        Vica_error(k)=sum(abs(Vica(k,:)/V0(k,:)-1))/(fmri_szX*fmri_szY);    % MRPE: Mean.Rel.Pred.Error
    end;
    
    if (flag_errshow)
        figure(1);
        plot(Vica_error);
        msg=sprintf('ICA reconstruction error using %d compoments',ica_Kp);
        title(msg);
    end;
    
    if (flag_imshow)
        fprintf('done\n\tdisplaying ICA-reconstructed (Kp=%d) pattern series... ',ica_Kp);
        for k=1:fmri_szT,
            figure(2);
            %imshow(mat2gray(Dica(:,:,k)'));
            imagesc(Dica(:,:,k)');
            colormap gray;
            title('fMRI sample series: ICA reconstruction');
            pause(1/disp_fps);
        end;
    end;

    if (flag_cmpshow)
        fprintf('done\n\tdisplaying ICA component-based reconstructions (Kp=%d)... ',ica_Kp);
        %close 3;        % make sure no previous components are displayed
        for k=1:fmri_szT,
            figure(3);
            cmpshow_szR=ceil(sqrt(ica_Kp+1));  % split the plot into appropriate sections
            cmpshow_szC=cmpshow_szR;
            for c=1:ica_Kp
                subplot(cmpshow_szR,cmpshow_szC,c);
                imagesc(Dica_cmp(:,:,k,c)');
                colormap gray;
                msg=sprintf('ICA.%d / |r|=%.3f',c,ACFica(c));
                title(msg);
            end;
            subplot(cmpshow_szR,cmpshow_szC,cmpshow_szR*cmpshow_szC);
            imagesc(Dica(:,:,k)');
            colormap gray;
            msg=sprintf('ICA.all / T=%d',k);
            title(msg);
            pause(1/disp_fps);
        end;
    end;
    
    % calculate correlation/p-value maps
    if ((flag_calcCorr)||(flag_calcPval))
        fprintf('done\n\tcalculating Correlation/P-value maps... ');
        % calculate correlation (RC) and p-value (PV) maps, convert to 2-D 'images' for plot
        % Note: PV should be examined along with sign(RC) for full component-wise inference
        [RC,PV]=vxCalcActivMap(T1,Vica,Pval_limit);
        RCM=vxDevectorize(RC,fmri_szX,fmri_szY);
        PVM=vxDevectorize(PV,fmri_szX,fmri_szY);
    
        if (flag_calcCorr)
            figure(4);
            mesh(RCM');
            title('Correlation matrix: full ICA / comp.T1');        
        end;
    
        if (flag_calcPval)
            figure(6);
            contour(PVM');
            title('P-value matrix: full ICA / comp.T1');        
        end;
        
        %close 5 7;        % make sure no previous components are displayed        
        cmpshow_szR=ceil(sqrt(ica_Kp+1));  % split the plot into appropriate sections
        cmpshow_szC=cmpshow_szR;
        for c=1:ica_Kp
            [RC,PV]=vxCalcActivMap(T1,vxVectorize(Dica_cmp(:,:,:,c)),Pval_limit);
            RCM=vxDevectorize(RC,fmri_szX,fmri_szY);
            PVM=vxDevectorize(PV,fmri_szX,fmri_szY);
            
            if (flag_calcCorr)
                figure(5);
                subplot(cmpshow_szR,cmpshow_szC,c);
                imagesc(RCM');
                msg=sprintf('ICA.%d / |r|=%.3f',c,ACFica(c));
                title(msg);
            end;

            if (flag_calcPval)
                figure(7);
                subplot(cmpshow_szR,cmpshow_szC,c);
                imagesc(PVM');
                msg=sprintf('ICA.%d / |r|=%.3f',c,ACFica(c));
                title(msg);
            end;
        end;           
    end;

    % calculate reconstruction inconsistency
    fprintf('done\n\tMean.Rel.Pred.Error: sum(|ICA/orig-1|)/n = %f\n',sum(sum(abs(Vica/V0-1)))/Nelem);
    
    if (flag_pause)
        fprintf('\n\t...<press any key to continue>...\n');
        pause;
    end;
end;

%... basic GLM analysis/reconstruction block ...
if (flag_doGLM)
    fprintf('\n\tperforming GLM (mvregress) decomposition of patterns series... ');
    D=ones(length(T1),4);     % create standard design matrix (K cols) 1st is for B0
    D(:,2)=T1;                % add column: ideal task-related response, continuous (soft)
    D(:,3)=T1t;               % add column: ideal task-related response, hard-thresholded
    D(:,4)=W(:,2);            % add column: transient task-related response, derivative-based
    
    % V0 (NxL): rows N are samples, cols L are variables (dim)
    % BETA (KxN): cols are GLM-beta coeffs (vectors), one for each data row (N)
    % Note: perform linear regression per-column (assummed independence)
    % Static activation map for component j can be retrieved with: 
    %     vxDevectorize( BETA(j,:), fmri_szX, fmri_szY )
    % Temporal activation series for component j is in:
    %     D(:,j)
    
    glm_Kp=size(D,2);
    warning('off','MATLAB:rankDeficientMatrix');           % turn off warning about bad-conditioned matrices
    BETA=zeros(size(D,2),size(V0,2));
    prg=0;  prg_prev=-1;                % initialize progress counters
    fprintf('\n\t\t');
    for k=1:size(V0,2)                  % treat each data column (L) independently
        [BETA(:,k),SIGMA,RESID]=mvregress(D,V0(:,k),'algorithm','cwls');      % perform GLM on 'flatttened' box pattern series
        
        prg=round(100*k/size(V0,2));            % calculate current progress (after one long GLM-fit step)
        if ((mod(prg,10)==0)&&(prg~=prg_prev))  % if not already at the same progress percentage (every 10%),
            fprintf('%.0f%% ',prg);             %    print new progress status
            prg_prev=prg;                       % and update flag (single printout)
        end;
    end;                                                   % using the same design matrix
    fprintf('done\n');
    warning('on','MATLAB:rankDeficientMatrix');            % restore warning about bad-conditioned matrices
    
    Vglm=D*BETA;                                        % GLM-reconstruct using the same design matrix (no rescaling)
    Dglm=vxDevectorize(Vglm,fmri_szX,fmri_szY);         % using: vxDevectorize32()

    ACFglm=zeros(glm_Kp,1);
    Dglm_cmp=zeros(fmri_szX,fmri_szY,fmri_szT,glm_Kp);  % per-component reconstruction (for further analysis)
    for c=1:glm_Kp
        ACFglm(c)=corr(T1,D(:,c));                      % per-component correlation coeff with primary activation series
        Dglm_cmp(:,:,:,c)=vxDevectorize(D(:,c)*BETA(c,:),fmri_szX,fmri_szY);
    end;       

    Vglm_error=zeros(fmri_szT,1);               % calculate per-slice reconstruction error
    for k=1:fmri_szT
        Vglm_error(k)=sum(abs(Vglm(k,:)/V0(k,:)-1))/(fmri_szX*fmri_szY);    % MRPE: Mean.Rel.Pred.Error
    end;
    
    if (flag_errshow)
        figure(1);
        plot(Vglm_error);
        msg=sprintf('GLM reconstruction error using %d compoments',size(D,2));
        title(msg);
    end;
    
    if (flag_imshow)
        fprintf('\tdisplaying GLM-reconstructed (Kp=%d) pattern series... ',glm_Kp);
        for k=1:fmri_szT,
            figure(2);
            %imshow(mat2gray(Dglm(:,:,k)'));
            imagesc(Dglm(:,:,k)');
            colormap gray;
            title('fMRI sample series: GLM reconstruction');
            pause(1/disp_fps);
        end;
    end;

    if (flag_cmpshow)
        fprintf('done\n\tdisplaying GLM component-based reconstructions (Kp=%d)... ',glm_Kp);
        %close 3;        % make sure no previous components are displayed        
        for k=1:fmri_szT,
            figure(3);
            cmpshow_szR=ceil(sqrt(glm_Kp+1));  % split the plot into appropriate sections
            cmpshow_szC=cmpshow_szR;
            for c=1:glm_Kp
                subplot(cmpshow_szR,cmpshow_szC,c);
                imagesc(Dglm_cmp(:,:,k,c)');
                colormap gray;
                msg=sprintf('GLM.%d / |r|=%.3f',c,ACFglm(c));
                title(msg);
            end;
            subplot(cmpshow_szR,cmpshow_szC,cmpshow_szR*cmpshow_szC);
            imagesc(Dglm(:,:,k)');
            colormap gray;
            msg=sprintf('GLM.all / T=%d',k);
            title(msg);
            pause(1/disp_fps);
        end;
    end;
    
    % calculate correlation/p-value maps
    if ((flag_calcCorr)||(flag_calcPval))
        fprintf('done\n\tcalculating Correlation/P-value maps... ');
        % calculate correlation (RC) and p-value (PV) maps, convert to 2-D 'images' for plot
        % Note: PV should be examined along with sign(RC) for full component-wise inference
        [RC,PV]=vxCalcActivMap(T1,Vglm,Pval_limit);
        RCM=vxDevectorize(RC,fmri_szX,fmri_szY);
        PVM=vxDevectorize(PV,fmri_szX,fmri_szY);
    
        if (flag_calcCorr)
            figure(4);
            mesh(RCM');
            title('Correlation matrix: full GLM / comp.T1');        
        end;
    
        if (flag_calcPval)
            figure(6);
            contour(PVM');
            title('P-value matrix: full GLM / comp.T1');        
        end;
        
        %close 5 7;        % make sure no previous components are displayed        
        cmpshow_szR=ceil(sqrt(glm_Kp+1));  % split the plot into appropriate sections
        cmpshow_szC=cmpshow_szR;
        for c=1:glm_Kp
            [RC,PV]=vxCalcActivMap(T1,vxVectorize(Dglm_cmp(:,:,:,c)),Pval_limit);
            RCM=vxDevectorize(RC,fmri_szX,fmri_szY);
            PVM=vxDevectorize(PV,fmri_szX,fmri_szY);
            
            if (flag_calcCorr)
                figure(5);
                subplot(cmpshow_szR,cmpshow_szC,c);
                imagesc(RCM');
                msg=sprintf('GLM.%d / |r|=%.3f',c,ACFglm(c));
                title(msg);
            end;

            if (flag_calcPval)
                figure(7);
                subplot(cmpshow_szR,cmpshow_szC,c);
                imagesc(PVM');
                msg=sprintf('GLM.%d / |r|=%.3f',c,ACFglm(c));
                title(msg);
            end;
        end;                   
    end;

    % calculate reconstruction inconsistency
    fprintf('done\n\tMean.Rel.Pred.Error: sum(|GLM/orig-1|)/n = %f\n',sum(sum(abs(Vglm/V0-1)))/Nelem);
    
    if (flag_pause)
        fprintf('\n\t...<press any key to continue>...\n');
        pause;
    end;
end;

%... basic CCA analysis/reconstruction block ...
if (flag_doCCA)
    fprintf('done\n\tperforming CCA decomposition of patterns series... ');
    D=ones(length(T1),4);     % create standard design matrix (K cols) 1st is for B0
    D(:,2)=T1;                % add column: ideal task-related response, continuous (soft)
    D(:,3)=T1t;               % add column: ideal task-related response, hard-thresholded
    D(:,4)=W(:,2);            % add column: transient task-related response, derivative-based

    DD=zeros(size(D));        % normalize compoments for CCA reconstruction
    for k=1:size(D,2)
        DD(:,k)=D(:,k)-mean(D(:,k));
    end;
    
    % V0 (NxL): rows N are samples, cols L are variables (dim)
    % A (Kx1): L cols of CCA coefficients for left-side matrix (DD)
    % B (1xL): L CCA coefficients for right-side column-vectors (V0(:,j))
    % Note: CCA normally maximizes correlation, i.e., not min-error reconstruction,
    % therefore 'reconstruction' should be compared against D instead of V0
    % Static activation map for component j can be retrieved with: 
    %     vxDevectorize( A(j,:)*B(1,c)^-1, fmri_szX, fmri_szY )
    % Temporal activation series for component j is in:
    %     DD(:,j)
    
    cca_Kp=size(D,2);
    Vcca=zeros(size(V0));
    A=zeros(cca_Kp,size(V0,2));
    B=zeros(1,size(V0,2));
    warning('off','stats:canoncorr:NotFullRank');       % turn off warning about bad-conditioned matrices
    for k=1:size(V0,2)
        [A(:,k) B(1,k) r U V] = canoncorr(D,V0(:,k));   % perform caconocal correlation analysis (X*A <-> Y*B)
        Vcca(:,k) = DD*A(:,k)*(B(1,k)^-1) + mean(V0(:,k));  % assume equality, perform CCA reconstruction (X*A*B^-1 = Y)
    end;
    fprintf('done\n');
    warning('on','stats:canoncorr:NotFullRank');        % turn off warning about bad-conditioned matrices
    Dcca=vxDevectorize(Vcca,fmri_szX,fmri_szY);         % using: vxDevectorize32()
    
    ACFcca=zeros(cca_Kp,1);
    Dcca_cmp=zeros(fmri_szX,fmri_szY,fmri_szT,cca_Kp);  % per-component reconstruction (for further analysis)
    for c=1:cca_Kp
        ACFcca(c)=corr(T1,DD(:,c));                      % per-component correlation coeff with primary activation series       
        Dcca_cmp(:,:,:,c)=vxDevectorize( DD(:,c)*A(c,:)*(B(1,c)^-1)+mean(V0(:,k)) ,fmri_szX,fmri_szY);
    end;       

    Vcca_error=zeros(fmri_szT,1);               % calculate per-slice reconstruction error
    for k=1:fmri_szT
        Vcca_error(k)=sum(abs(Vcca(k,:)/V0(k,:)-1))/(fmri_szX*fmri_szY);    % MRPE: Mean.Rel.Pred.Error
    end;
    
    if (flag_errshow)
        figure(1);
        plot(Vcca_error);
        msg=sprintf('CCA reconstruction error using %d compoments',size(D,2));
        title(msg);
    end;
    
    if (flag_imshow)
        fprintf('\tdisplaying CCA-reconstructed (Kp=%d) pattern series... ',cca_Kp);
        for k=1:fmri_szT,
            figure(2);
            %imshow(mat2gray(Dcca(:,:,k)'));
            %subplot(1,2,1);
            %image(100*D1(:,:,k)');            
            %subplot(1,2,2);
            imagesc(Dcca(:,:,k)');
            colormap gray;
            title('fMRI sample series: CCA reconstruction');
            pause(1/disp_fps);
        end;
    end;

    if (flag_cmpshow)
        fprintf('done\n\tdisplaying CCA component-based reconstructions (Kp=%d)... ',cca_Kp);
        %close 3;        % make sure no previous components are displayed        
        for k=1:fmri_szT,
            figure(3);
            cmpshow_szR=ceil(sqrt(cca_Kp+1));  % split the plot into appropriate sections
            cmpshow_szC=cmpshow_szR;
            for c=1:cca_Kp
                subplot(cmpshow_szR,cmpshow_szC,c);
                imagesc(Dcca_cmp(:,:,k,c)');
                colormap gray;
                msg=sprintf('CCA.%d / |r|=%.3f',c,ACFcca(c));
                title(msg);
            end;
            subplot(cmpshow_szR,cmpshow_szC,cmpshow_szR*cmpshow_szC);
            imagesc(Dcca(:,:,k)');
            colormap gray;
            msg=sprintf('CCA.all / T=%d',k);
            title(msg);
            pause(1/disp_fps);
        end;
    end;
    
    % calculate correlation/p-value maps
    if ((flag_calcCorr)||(flag_calcPval))
        fprintf('done\n\tcalculating Correlation/P-value maps... ');
        % calculate correlation (RC) and p-value (PV) maps, convert to 2-D 'images' for plot
        % Note: PV should be examined along with sign(RC) for full component-wise inference
        [RC,PV]=vxCalcActivMap(T1,Vcca,Pval_limit);
        RCM=vxDevectorize(RC,fmri_szX,fmri_szY);
        PVM=vxDevectorize(PV,fmri_szX,fmri_szY);
    
        if (flag_calcCorr)
            figure(4);
            mesh(RCM');
            title('Correlation matrix: full CCA / comp.T1');        
        end;
    
        if (flag_calcPval)
            figure(6);
            contour(PVM');
            title('P-value matrix: full CCA / comp.T1');        
        end;
        
        %close 5 7;        % make sure no previous components are displayed        
        cmpshow_szR=ceil(sqrt(cca_Kp+1));  % split the plot into appropriate sections
        cmpshow_szC=cmpshow_szR;
        for c=1:cca_Kp
            [RC,PV]=vxCalcActivMap(T1,vxVectorize(Dcca_cmp(:,:,:,c)),Pval_limit);
            RCM=vxDevectorize(RC,fmri_szX,fmri_szY);
            PVM=vxDevectorize(PV,fmri_szX,fmri_szY);
            
            if (flag_calcCorr)
                figure(5);
                subplot(cmpshow_szR,cmpshow_szC,c);
                imagesc(RCM');
                msg=sprintf('CCA.%d / |r|=%.3f',c,ACFcca(c));
                title(msg);
            end;

            if (flag_calcPval)
                figure(7);
                subplot(cmpshow_szR,cmpshow_szC,c);
                imagesc(PVM');
                msg=sprintf('CCA.%d / |r|=%.3f',c,ACFcca(c));
                title(msg);
            end;
        end;                   
    end;

    % calculate reconstruction inconsistency
    fprintf('done\n\tMean.Rel.Pred.Error: sum(|CCA/orig-1|)/n = %f\n',sum(sum(abs(Vcca/V0-1)))/Nelem);
    
    if (flag_pause)
        fprintf('\n\t...<press any key to continue>...\n');
        pause;
    end;
end;

%... basic MP analysis/reconstruction block ...
if (flag_doMP)
    fprintf('\n\tperforming MP:%s (wmpalg) decomposition of patterns series... ',mp_alg);
    D=ones(length(T1),4);     % create standard design matrix (K cols) 1st is for B0
    D(:,2)=T1;                % add column: ideal task-related response, continuous (soft)
    D(:,3)=T1t;               % add column: ideal task-related response, hard-thresholded
    D(:,4)=W(:,2);            % add column: transient task-related response, derivative-based

    % V0 (NxL): rows N are samples, cols L are variables (dim)
    % MPC (KxL): rows K are dictionary components (coeffs) calculated by MP
    % MPI (KxL): rows K are dictionary components (indices) calculated by MP
    % Note: perform MP decomposition per-column (assummed independence)
    % Static activation map for component j can be retrieved with: 
    %     vxDevectorize( MPC(MPI(j,:)), fmri_szX, fmri_szY )
    % Temporal activation series for component j is in:
    %     DD(:,MPI(j,:)')
        
    MPC=zeros(size(D,2),size(V0,2));
    MPI=zeros(size(D,2),size(V0,2));
    mp_Kp=size(D,2);
    prg=0;  prg_prev=-1;                % initialize progress counters
    fprintf('\n\t\t');
    for c=1:size(V0,2)                                     % treat each data column (L) independently        
        [YFIT,R,MPC(:,c),IOPT,QUAL,DD] = wmpalg(mp_alg,V0(:,c),D);      % perform MP on 'flatttened' box pattern series
        MPI(:,c)=IOPT';
        prg=round(100*c/size(V0,2));            % calculate current progress (after one long GLM-fit step)
        if ((mod(prg,10)==0)&&(prg~=prg_prev))  % if not already at the same progress percentage (every 10%),
            fprintf('%.0f%% ',prg);             %    print new progress status
            prg_prev=prg;                       % and update flag (single printout)
        end;
    end;                                                    % using the same dictionary matrix
    fprintf('done\n');
    
    if ((mp_Kp<1)||(mp_Kp>size(V0,2)))
        mp_Kp=size(V0,2);
    end;
    Vmp=zeros(size(V0));
    for c=1:size(V0,2)                 % MP-reconstruct using the same (original) dictionary matrix (normalized)
        Vmp(:,c)=DD(:,MPI(1:mp_Kp,c)')*MPC(MPI(1:mp_Kp,c),c);      % using olny the top Kp (sparse) components
    end;
    Dmp=vxDevectorize(Vmp,fmri_szX,fmri_szY);           % using: vxDevectorize32()

    ACFmp=zeros(mp_Kp,1);
    Dmp_cmp=zeros(fmri_szX,fmri_szY,fmri_szT,mp_Kp);    % per-component reconstruction (for further analysis)
    Vmpk=zeros(size(Vmp));
    for c=1:mp_Kp
        ACFmp(c)=corr(T1,D(:,c));                       % per-component correlation coeff with primary activation series        
        for k=1:size(V0,2)             % MP-reconstruct using the same (original) dictionary matrix (normalized)
            Vmpk(:,k)=DD(:,MPI(c,k)')*MPC(MPI(c,k),k);      % using only the ... (sparse) component
        end;
        Dmp_cmp(:,:,:,c)=vxDevectorize(Vmpk,fmri_szX,fmri_szY);
    end;       

    Vmp_error=zeros(fmri_szT,1);               % calculate per-slice reconstruction error
    for k=1:fmri_szT
        Vmp_error(k)=sum(abs(Vmp(k,:)/V0(k,:)-1))/(fmri_szX*fmri_szY);    % MRPE: Mean.Rel.Pred.Error
    end;
    
    if (flag_errshow)
        figure(1);
        plot(Vmp_error);
        msg=sprintf('MP:%s reconstruction error using %d compoments',mp_alg,mp_Kp);
        title(msg);
    end;
    
    if (flag_imshow)
        fprintf('\tdisplaying MP:%s-reconstructed (Kp=%d) pattern series... ',mp_alg,mp_Kp);
        for k=1:fmri_szT,
            figure(2);
            %imshow(mat2gray(Dmp(:,:,k)'));
            imagesc(Dmp(:,:,k)');
            colormap gray;
            title('fMRI sample series: MP reconstruction');
            pause(1/disp_fps);
        end;
    end;

    if (flag_cmpshow)
        fprintf('done\n\tdisplaying MP:%s component-based reconstructions (Kp=%d)... ',mp_alg,mp_Kp);
        %close 3;        % make sure no previous components are displayed        
        for k=1:fmri_szT,
            figure(3);
            cmpshow_szR=ceil(sqrt(mp_Kp+1));  % split the plot into appropriate sections
            cmpshow_szC=cmpshow_szR;
            for c=1:mp_Kp
                subplot(cmpshow_szR,cmpshow_szC,c);
                imagesc(Dmp_cmp(:,:,k,c)');
                colormap gray;
                msg=sprintf('MP:%s.%d / |r|=%.3f',mp_alg,c,ACFmp(c));
                title(msg);
            end;
            subplot(cmpshow_szR,cmpshow_szC,cmpshow_szR*cmpshow_szC);
            imagesc(Dmp(:,:,k)');
            colormap gray;
            msg=sprintf('MP:%s.all / T=%d',mp_alg,k);
            title(msg);
            pause(1/disp_fps);
        end;
    end;
    
    % calculate correlation/p-value maps
    if ((flag_calcCorr)||(flag_calcPval))
        fprintf('done\n\tcalculating Correlation/P-value maps... ');
        % calculate correlation (RC) and p-value (PV) maps, convert to 2-D 'images' for plot
        % Note: PV should be examined along with sign(RC) for full component-wise inference
        [RC,PV]=vxCalcActivMap(T1,Vmp,Pval_limit);
        RCM=vxDevectorize(RC,fmri_szX,fmri_szY);
        PVM=vxDevectorize(PV,fmri_szX,fmri_szY);
    
        if (flag_calcCorr)
            figure(4);
            mesh(RCM');
            title('Correlation matrix: full MP / comp.T1');        
        end;
    
        if (flag_calcPval)
            figure(6);
            contour(PVM');
            title('P-value matrix: full MP / comp.T1');        
        end;
        
        %close 5 7;        % make sure no previous components are displayed        
        cmpshow_szR=ceil(sqrt(mp_Kp+1));  % split the plot into appropriate sections
        cmpshow_szC=cmpshow_szR;
        for c=1:mp_Kp
            [RC,PV]=vxCalcActivMap(T1,vxVectorize(Dmp_cmp(:,:,:,c)),Pval_limit);
            RCM=vxDevectorize(RC,fmri_szX,fmri_szY);
            PVM=vxDevectorize(PV,fmri_szX,fmri_szY);
            
            if (flag_calcCorr)
                figure(5);
                subplot(cmpshow_szR,cmpshow_szC,c);
                imagesc(RCM');
                msg=sprintf('MP:%s.%d / |r|=%.3f',mp_alg,c,ACFmp(c));
                title(msg);
            end;

            if (flag_calcPval)
                figure(7);
                subplot(cmpshow_szR,cmpshow_szC,c);
                imagesc(PVM');
                msg=sprintf('MP:%s.%d / |r|=%.3f',mp_alg,c,ACFmp(c));
                title(msg);
            end;
        end;                   
    end;

    % calculate reconstruction inconsistency
    fprintf('done\n\tMean.Rel.Pred.Error: sum(|MP:%s/orig-1|)/n = %f\n',mp_alg,sum(sum(abs(Vmp/V0-1)))/Nelem);
    
    if (flag_pause)
        fprintf('\n\t...<press any key to continue>...\n');
        pause;
    end;
end;

%... basic KSVD analysis/reconstruction block ...
if (flag_doKSVD)
    fprintf('\n\tperforming KSVD decomposition of patterns series...\n');

    % V0 (NxL): rows N are samples, cols L are variables (dim)
    % Dict (NxK): ICA mixing matrix for K components
    % outpar.CoefMatrix (KxL): rows K are ICA components (vectors) of length L
    % Note: sparse-encode into param.K dictionary atoms, use param.L atoms per signal (L<=K)
    % Static activation map for component j can be retrieved with: 
    %     vxDevectorize( outpar.CoefMatrix(j,:), fmri_szX, fmri_szY )
    % Temporal activation series for component j is in:
    %     Dict(:,j)
    
    param.K=ksvd_Kp;
    param.L=ksvd_Lp;
    param.numIteration=ksvd_iterN;
    param.errorFlag=ksvd_mode;
    if (ksvd_useNNMF), ksvd_fixedDC=0; end;     % disable fixedDC for non-neg.mat.fact. KSVD
    param.preserveDCAtom=ksvd_fixedDC;
    param.InitializationMethod='DataElements';
    param.displayProgress=1;
    param.errorGoal=ksvd_errStop;
    
    if (ksvd_useNNMF)
        [Dict,outpar] = KSVD_NN(V0,param);      % non-neg.mat.fact. KSVD (coding: OMP)
    else
        [Dict,outpar] = KSVD(V0,param);         % standard KSVD (coding: OMP)
    end;
    
    Vksvd=Dict*outpar.CoefMatrix;      % KSVD-reconstruct using the dictionary encoding
    Dksvd=vxDevectorize(Vksvd,fmri_szX,fmri_szY);         % using: vxDevectorize32()
       
    ACFksvd=zeros(ksvd_Kp,1);
    Dksvd_cmp=zeros(fmri_szX,fmri_szY,fmri_szT,ksvd_Kp);  % per-component reconstruction (for further analysis)
    for c=1:ksvd_Kp
        ACFksvd(c)=corr(T1,Dict(:,c));                      % per-component correlation coeff with primary activation series
        Dksvd_cmp(:,:,:,c)=vxDevectorize(Dict(:,c)*outpar.CoefMatrix(c,:),fmri_szX,fmri_szY);
    end;       
        
    Vksvd_error=zeros(fmri_szT,1);               % calculate per-slice reconstruction error
    for k=1:fmri_szT
        Vksvd_error(k)=sum(abs(Vksvd(k,:)/V0(k,:)-1))/(fmri_szX*fmri_szY);    % MRPE: Mean.Rel.Pred.Error
    end;
    
    if (flag_errshow)
        figure(1);
        plot(Vksvd_error);
        msg=sprintf('KSVD reconstruction error using %d compoments',ksvd_Kp);
        title(msg);
    end;
    
    if (flag_imshow)
        fprintf('done\n\tdisplaying KSVD-reconstructed (Kp=%d) pattern series... ',ksvd_Kp);
        for k=1:fmri_szT,
            figure(2);
            %imshow(mat2gray(Dksvd(:,:,k)'));
            imagesc(Dksvd(:,:,k)');
            colormap gray;
            title('fMRI sample series: KSVD reconstruction');
            pause(1/disp_fps);
        end;
    end;

    if (flag_cmpshow)
        fprintf('done\n\tdisplaying KSVD component-based reconstructions (Kp=%d)... ',ksvd_Kp);
        %close 3;        % make sure no previous components are displayed
        for k=1:fmri_szT,
            figure(3);
            cmpshow_szR=ceil(sqrt(ksvd_Kp+1));  % split the plot into appropriate sections
            cmpshow_szC=cmpshow_szR;
            for c=1:ksvd_Kp                     % display all atoms plus full reconstruction
                subplot(cmpshow_szR,cmpshow_szC,c);
                imagesc(Dksvd_cmp(:,:,k,c)');
                colormap gray;
                msg=sprintf('KSVD.%d / |r|=%.3f',c,ACFksvd(c));
                title(msg);
            end;
            subplot(cmpshow_szR,cmpshow_szC,cmpshow_szR*cmpshow_szC);
            imagesc(Dksvd(:,:,k)');
            colormap gray;
            msg=sprintf('KSVD.all / T=%d',k);
            title(msg);
            pause(1/disp_fps);
        end;
    end;
    
    % calculate correlation/p-value maps
    if ((flag_calcCorr)||(flag_calcPval))
        fprintf('done\n\tcalculating Correlation/P-value maps... ');
        % calculate correlation (RC) and p-value (PV) maps, convert to 2-D 'images' for plot
        % Note: PV should be examined along with sign(RC) for full component-wise inference
        [RC,PV]=vxCalcActivMap(T1,Vksvd,Pval_limit);
        RCM=vxDevectorize(RC,fmri_szX,fmri_szY);
        PVM=vxDevectorize(PV,fmri_szX,fmri_szY);
    
        if (flag_calcCorr)
            figure(4);
            mesh(RCM');
            title('Correlation matrix: full KSVD / comp.T1');        
        end;
    
        if (flag_calcPval)
            figure(6);
            contour(PVM');
            title('P-value matrix: full KSVD / comp.T1');        
        end;
        
        %close 5 7;        % make sure no previous components are displayed        
        for c=1:ksvd_Kp
            [RC,PV]=vxCalcActivMap(T1,vxVectorize(Dksvd_cmp(:,:,:,c)),Pval_limit);
            RCM=vxDevectorize(RC,fmri_szX,fmri_szY);
            PVM=vxDevectorize(PV,fmri_szX,fmri_szY);
            
            if (flag_calcCorr)
                figure(5);
                subplot(cmpshow_szR,cmpshow_szC,c);
                imagesc(RCM');
                msg=sprintf('KSVD.%d / |r|=%.3f',c,ACFksvd(c));
                title(msg);
            end;

            if (flag_calcPval)
                figure(7);
                subplot(cmpshow_szR,cmpshow_szC,c);
                imagesc(PVM');
                msg=sprintf('KSVD.%d / |r|=%.3f',c,ACFksvd(c));
                title(msg);
            end;
        end;           
    end;

    % calculate reconstruction inconsistency
    fprintf('done\n\tMean.Rel.Pred.Error: sum(|KSVD/orig-1|)/n = %f\n',sum(sum(abs(Vksvd/V0-1)))/Nelem);
    
    if (flag_pause)
        fprintf('\n\t...<press any key to continue>...\n');
        pause;
    end;
end;


%... cleanup / exit ...
fprintf('\n');

tt=toc;
fprintf('All finished in %.2f seconds\n',toc);
